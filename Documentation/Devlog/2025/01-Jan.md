# January 2025
## Jan 18, 2025 - Diversions, the process of discovery and doing things the hard way.
Since the update in April of last year, I traveled to India to reunite with my wife after a long visa process. I took a printout of the informal source-code and a hardcover notebook to program offline. Detail oriented work like building the parser or reverse-engineering binary formats wasn't a good fit for this mode of working, so I shifted my focus back to a problem I've been obsessed with: Pattern Matching.
There began a six month+ diversion into pattern matching algorithms. I made very little progress on actual code during this time, but worked through the more abstract problems in the back of my mind as life and work took my primary focus. Diversions like this are one of the joys and challenges of working independently. It's easy to get lost on such tangents without the structure of an organization and goal-oriented project management. But not all who wander are lost, and while many of these tangents end in dead-ends they form the dots that later connect in surprising ways. Exploration is the method of discovery, while navigating well-known milestones is the more surefire path of progress.
When I worked on this project full-time in the past, I didn't have the liberty to take such a long-winded diversions with nothing meaningful to show for it. There is a difference in mindset between approaching a project professionally as work, versus approaching it as a more creative, artistic expression of a craft. That influences every choice you make, every day. A craft is practiced for its own merits, for the innate joy of creating something, of solving difficult problems. You follow the path of curiosity, of challenges rather than the path of least resistence.
That has become a core principle for informal: Do things the hard way. Explore the unexplored tangents, follow your curiosity and take on the challenges that intimidate you. There is no deadline - I am commited to this project for the long-term - so don't just build the minimum viable product, do it right. Don't just transpile to C or output LLVM - do it the hard way and go all the way to assembly. Don't just link to existing C standard libs, do it the hard way and build it from scratch.
As in all things, there is a balance to this though. I came to a good algorithm for pattern matching, struggled through expressing the ideas in code that captured that same elegance, finally arrived at a simple structure that laid out the bare bones. It's not complete, but this tangent felt further and further from the language I wanted to build. There is an abstract, metacircular, macro-driven version of the compiler I want to ultimately build. But abstracting something before you have something concrete is one of the classic software engineering pitfalls. So I've returned back to the Zig version of the compiler, doing things the long and hard way. I picked up all of the pieces I laid down months ago and connected it into a full pipleline from very simple expressions to an executable binary.
There is a long path ahead to the language I have in mind, filled with many more tangents. But that is the process of discovery. The language will evolve through that journey, and so will I.
